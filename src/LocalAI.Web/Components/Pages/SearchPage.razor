@page "/search"
@using LocalAI.Web.Services
@using LocalAI.Core.Models
@using LocalAI.Web.Models
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.AspNetCore.Components
@using System.IO
@using Markdig
@inject IApiService ApiService
@inject IConversationService ConversationService
@inject IConfiguration Configuration
@rendermode @(new InteractiveServerRenderMode(prerender: false))

<PageTitle>Knowledge Search</PageTitle>

<div class="claude-chat-container">
    <div class="chat-layout">
        <!-- Chat History Sidebar -->
        <div class="sidebar @(isSidebarOpen ? "open" : "")">
            <div class="sidebar-header">
                <h2>Conversations</h2>
                <button class="close-sidebar-btn" @onclick="ToggleSidebar">✕</button>
            </div>
            <div class="sidebar-content">
                <button class="new-chat-btn" @onclick="() => StartNewChat()">
                    <span>+</span> New Chat
                </button>
                <div class="conversations-list">
                    @if (conversationsLoading)
                    {
                        <div class="loading">Loading conversations...</div>
                    }
                    else
                    {
                        @foreach (var conv in conversations)
                        {
                            <div class="conversation-item @(currentConversation?.Id == conv.Id ? "active" : "")" 
                                 @onclick="() => LoadConversation(conv.Id)"
                                 @onmouseover="() => ShowPreview(conv.Id)"
                                 @onmouseout="() => HidePreview()">
                                <div class="conversation-header">
                                    @if (editingConversationId == conv.Id)
                                    {
                                        <input type="text" class="conversation-title-edit" @bind="editTitle" @onkeydown="@(e => HandleTitleEditKeydown(e, conv.Id))" @ref="titleEditInput" />
                                        <button class="save-title-btn" @onclick="() => SaveTitle(conv.Id)">✓</button>
                                        <button class="cancel-title-btn" @onclick="CancelEditTitle">✗</button>
                                    }
                                    else
                                    {
                                        <div class="conversation-title">@GetConversationTitle(conv)</div>
                                        <button class="edit-title-btn" @onclick="() => StartEditTitle(conv.Id, conv.Title)">✏️</button>
                                        <button class="delete-conversation-btn" @onclick="() => DeleteConversation(conv.Id)">🗑️</button>
                                    }
                                </div>
                                <div class="conversation-date">@conv.UpdatedAt.ToString("MMM d, h:mm tt")</div>
                                @if (previewedConversationId == conv.Id && conversationPreviews.ContainsKey(conv.Id))
                                {
                                    <div class="conversation-preview">@conversationPreviews[conv.Id]</div>
                                }
                            </div>
                        }
                    }
                </div>
            </div>
        </div>

        <!-- Main Chat Area -->
        <div class="main-content">
            <!-- Sidebar Toggle Button (Mobile) -->
            <button class="sidebar-toggle" @onclick="ToggleSidebar">☰</button>

            <div class="chat-main" @ref="chatContainer">
                @if (searchError != "")
                {
                    <div class="error-banner">
                        <span class="error-icon">⚠️</span>
                        <span class="error-text">@searchError</span>
                    </div>
                }

                <!-- Conversation History -->
                <div class="messages-container">
                    @if (!conversationHistory.Any() && searchResponse == null)
                    {
                        <div class="welcome-message">
                            <div class="welcome-content">
                                <div class="welcome-icon">🧠</div>
                                <h2>Welcome to Your Knowledge Assistant</h2>
                                <p>Ask anything about your documents and I'll search through your knowledge base to find answers.
                                </p>
                                <button class="toggle-examples-btn" @onclick="ToggleExamples">@showExamplesButtonText</button>
                                @if (showExamples)
                                {
                                    <div class="welcome-examples">
                                        <div class="example-item">"Tell me about Azure pricing models"</div>
                                        <div class="example-item">"What are the key features of .NET 9?"</div>
                                        <div class="example-item">"Summarize the main points from the LLM research papers"</div>
                                    </div>
                                }
                            </div>
                        </div>
                    }
                    else
                    {
                        @foreach (var item in conversationHistory)
                        {
                            <div class="message user-message">
                                <div class="message-avatar user-avatar">
                                    <span>👤</span>
                                </div>
                                <div class="message-content">
                                    <div class="message-text">@item.Query</div>
                                    <div class="message-timestamp">@item.Timestamp.ToString("MMM d, h:mm tt")</div>
                                </div>
                            </div>
                            <div class="message assistant-message">
                                <div class="message-avatar assistant-avatar">
                                    <span>🤖</span>
                                </div>
                                <div class="message-content">
                                    <div class="message-text">@((MarkupString)FormatResponse(item.Response))</div>
                                    @if (HasSources(item.Response))
                                    {
                                        <div class="sources-indicator">Sources cited below</div>
                                    }
                                </div>
                            </div>
                        }

                        @if (searchResponse != null && !conversationHistory.Any(ch => ch.Query == searchResponse.Query))
                        {
                            <div class="message user-message">
                                <div class="message-avatar user-avatar">
                                    <span>👤</span>
                                </div>
                                <div class="message-content">
                                    <div class="message-text">@searchResponse.Query</div>
                                </div>
                            </div>
                            <div class="message assistant-message">
                                <div class="message-avatar assistant-avatar">
                                    <span>🤖</span>
                                </div>
                                <div class="message-content">
                                    @if (!string.IsNullOrEmpty(searchResponse.RAGResponse))
                                    {
                                        <div class="message-text">@((MarkupString)FormatResponse(searchResponse.RAGResponse))</div>
                                        @if (searchResponse.Timing != null &&
                                                            !string.IsNullOrEmpty(searchResponse.Timing.FormattedResponseTime))
                                        {
                                            <div class="response-metadata">
                                                <div class="response-time">Responded in @searchResponse.Timing.FormattedResponseTime</div>
                                                @if (searchResponse.Timing.TotalTimeMs > 0)
                                                {
                                                    <div class="response-details">
                                                        <span class="detail-item">Search: @searchResponse.Timing.SearchTimeMs.ToString("F2")ms</span>
                                                        <span class="detail-item">Generation: @searchResponse.Timing.GenerationTimeMs.ToString("F2")ms</span>
                                                        @if (searchResponse.Timing.GenerationTimeMs > 0)
                                                        {
                                                            <span class="detail-item">Tokens/sec: @((1000 / searchResponse.Timing.GenerationTimeMs).ToString("F1"))</span>
                                                        }
                                                    </div>
                                                }
                                            </div>
                                        }
                                        @if (HasSources(searchResponse.RAGResponse))
                                        {
                                            <div class="sources-indicator">Sources cited below</div>
                                        }
                                    }
                                    else
                                    {
                                        <div class="message-text no-response">No response generated.</div>
                                    }
                                </div>
                            </div>
                        }
                    }
                </div>
            </div>

            <!-- Sources Section (only show when there's a response) -->
            @if (searchResponse != null && searchResponse.Sources?.Any() == true)
            {
                <div class="sources-section">
                    <div class="sources-header">
                        <h3>Sources (@searchResponse.Sources.Count)</h3>
                        <button class="toggle-sources-btn" @onclick="ToggleSourcesVisibility">
                            @if (areSourcesVisible)
                            {
                                <span>Hide Sources</span>
                            }
                            else
                            {
                                <span>Show Sources</span>
                            }
                        </button>
                    </div>
                    @if (areSourcesVisible)
                    {
                        <div class="sources-grid">
                            @foreach (var source in searchResponse.Sources)
                            {
                                <div class="source-card">
                                    <div class="source-header">
                                        <h4 class="source-title">📄 @GetSourceName(source.Source)</h4>
                                        <span class="source-score">@(((int)(source.Score * 100)).ToString())%</span>
                                    </div>
                                    @if (!string.IsNullOrEmpty(source.PageInfo))
                                    {
                                        <div class="source-page">@source.PageInfo</div>
                                    }
                                    <div class="source-content">
                                        @if (IsSourceExpanded(source))
                                        {
                                            @source.Content
                                        }
                                        else
                                        {
                                            @TruncateContent(source.Content, 150)
                                        }
                                    </div>
                                    <button class="toggle-content-btn" @onclick="() => ToggleSourceExpansion(source)">
                                        @if (IsSourceExpanded(source))
                                        {
                                            <span>Show Less</span>
                                        }
                                        else
                                        {
                                            <span>Show More</span>
                                        }
                                    </button>
                                </div>
                            }
                        </div>
                    }
                </div>
            }

            <!-- Input Area -->
            @if (useOpenRouter)
            {
                <div class="model-selector">
                    <label>
                        <input type="radio" name="model" value="local" checked="@(selectedModel == "local")" @onclick='() => SetModel("local")' />
                        Local LLM
                    </label>
                    <label>
                        <input type="radio" name="model" value="qwen3-coder" checked="@(selectedModel == "qwen3-coder")" @onclick='() => SetModel("qwen3-coder")' />
                        Qwen3-Coder
                    </label>
                </div>
            }
            <div class="chat-input-container">
                <div class="input-area">
                    <div class="input-actions">
                        <button class="clear-btn" @onclick="ClearConversation" title="Clear conversation">
                            🗑️
                        </button>
                    </div>
                    <textarea class="chat-input" placeholder="Ask anything about your knowledge base..." @bind="searchQuery"
                        @onkeypress="OnKeyPress" @oninput="OnInput" disabled="@isSearching" rows="1">
                    </textarea>
                    <button class="send-btn" @onclick="PerformSearch"
                        disabled="@(isSearching || string.IsNullOrWhiteSpace(searchQuery))">
                        @if (isSearching)
                        {
                            <span class="spinner"></span>
                        }
                        else
                        {
                            <span>➤</span>
                        }
                    </button>
                </div>
                <div class="input-hint">
                    Press Enter to send, Shift+Enter for new line
                </div>
            </div>
        </div>
    </div>
</div>

@code {
    private string searchQuery = "";
    private bool isSearching = false;
    private bool isProcessing = false;
    private bool collectionExists = false;
    private string statusMessage = "";
    private string searchError = "";
    private LocalAI.Web.Services.SearchResponse? searchResponse;
    private bool isResponseExpanded = false;
    private HashSet<LocalAI.Core.Models.SearchResult> expandedSources = new HashSet<LocalAI.Core.Models.SearchResult>();
    private List<ConversationHistoryItem> conversationHistory = new List<ConversationHistoryItem>();
    private ElementReference chatContainer;
    private bool areSourcesVisible = false;
    private string selectedModel = "local";
    private bool useOpenRouter = false;
    
    // Chat management properties
    private List<LocalAI.Core.Models.ChatConversationSummary> conversations = new List<LocalAI.Core.Models.ChatConversationSummary>();
    private LocalAI.Core.Models.ChatConversation? currentConversation;
    private bool isSidebarOpen = true;
    private bool conversationsLoading = false;
    
    // Conversation management properties
    private Guid editingConversationId = Guid.Empty;
    private string editTitle = "";
    private ElementReference titleEditInput;
    private Guid previewedConversationId = Guid.Empty;
    private Dictionary<Guid, string> conversationPreviews = new Dictionary<Guid, string>();
    private bool showExamples = true;
    
    private string showExamplesButtonText => showExamples ? "Hide Examples" : "Show Examples";

    protected override async Task OnInitializedAsync()
    {
        useOpenRouter = Configuration.GetValue<bool>("OpenRouter:UseOpenRouter");
        Console.WriteLine("OnInitializedAsync called");
        await CheckCollectionStatus();
        conversationHistory = await ConversationService.GetConversationHistoryAsync();
        Console.WriteLine($"Loaded {conversationHistory.Count} items from conversation history");
        
        // Create initial conversation
        await CreateInitialConversation();
        await LoadConversations();
        Console.WriteLine("OnInitializedAsync completed");
    }

    private async Task CreateInitialConversation()
    {
        try
        {
            Console.WriteLine("Creating initial conversation");
            var response = await ApiService.CreateConversationAsync();
            if (response.Success && response.Data != null)
            {
                currentConversation = response.Data;
                Console.WriteLine($"Initial conversation created: {currentConversation.Id}");
            }
            else
            {
                Console.WriteLine($"Failed to create initial conversation: {response.Error}");
                // Initialize with a null conversation if API fails
                currentConversation = null;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error creating initial conversation: {ex.Message}");
            Console.WriteLine($"Stack trace: {ex.StackTrace}");
            // Initialize with a null conversation if API fails
            currentConversation = null;
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // Scroll to bottom of chat only on first render
        if (firstRender)
        {
            await chatContainer.FocusAsync();
        }
    }

    private async Task CheckCollectionStatus()
    {
        try
        {
            var response = await ApiService.GetCollectionStatusAsync();
            if (response.Success && response.Data != null)
            {
                collectionExists = response.Data.CollectionExists;
                statusMessage = collectionExists
                ? "Knowledge base is ready! You can start searching your documents."
                : "Knowledge base not found. Process your documents first to enable search.";
            }
            else
            {
                statusMessage = "Unable to check knowledge base status. Make sure the API is running.";
            }
        }
        catch (Exception ex)
        {
            statusMessage = $"Error checking status: {ex.Message}";
        }
    }

    private async Task ProcessDocuments()
    {
        isProcessing = true;
        try
        {
            var response = await ApiService.ProcessDocumentsAsync();
            if (response.Success && response.Data != null)
            {
                statusMessage = response.Data.Message;
                if (response.Data.Success)
                {
                    collectionExists = true;
                    statusMessage = $"✅ Successfully processed {response.Data.ChunksProcessed} document chunks!";
                }
            }
            else
            {
                statusMessage = $"Error processing documents: {response.Error}";
            }
        }
        catch (Exception ex)
        {
            statusMessage = $"Error: {ex.Message}";
        }
        finally
        {
            isProcessing = false;
        }
    }

    private async Task PerformSearch()
    {
        if (string.IsNullOrWhiteSpace(searchQuery)) return;

        isSearching = true;
        searchError = "";
        searchResponse = null;

        try
        {
            var context = await ConversationService.GetRecentContextAsync(3);

            if (selectedModel == "qwen3-coder" && useOpenRouter)
            {
                var response = await ApiService.CodeSearchAsync(searchQuery.Trim(), context);
                if (response.Success && response.Data != null)
                {
                    searchResponse = new LocalAI.Web.Services.SearchResponse
                    {
                        Query = searchQuery.Trim(),
                        RAGResponse = response.Data.Response,
                        HasResults = true
                    };

                    await ConversationService.AddToConversationHistoryAsync(searchQuery.Trim(), searchResponse.RAGResponse);
                    conversationHistory = await ConversationService.GetConversationHistoryAsync();

                    if (currentConversation != null)
                    {
                        await ApiService.AddMessageToConversationAsync(currentConversation.Id, "user", searchQuery.Trim());
                        await ApiService.AddMessageToConversationAsync(currentConversation.Id, "assistant", searchResponse.RAGResponse);
                        
                        // Auto-generate title from first query if it's still "New Chat"
                        if (currentConversation.Title == "New Chat" && conversations != null)
                        {
                            var conversation = conversations.FirstOrDefault(c => c.Id == currentConversation.Id);
                            if (conversation != null)
                            {
                                // Generate a title from the first few words of the query
                                var title = searchQuery.Trim();
                                if (title.Length > 30)
                                {
                                    title = title.Substring(0, 30) + "...";
                                }
                                conversation.Title = title;
                                currentConversation.Title = title;
                                
                                // Refresh the conversation list to show the updated title
                                await LoadConversations();
                            }
                        }
                    }
                }
                else
                {
                    searchError = response.Error ?? "Unknown error occurred";
                }
            }
            else
            {
                var response = await ApiService.SearchAsync(searchQuery.Trim(), 8, context);
                if (response.Success && response.Data != null)
                {
                    searchResponse = response.Data;

                    await ConversationService.AddToConversationHistoryAsync(searchQuery.Trim(), searchResponse.RAGResponse);
                    conversationHistory = await ConversationService.GetConversationHistoryAsync();

                    if (currentConversation != null)
                    {
                        await ApiService.AddMessageToConversationAsync(currentConversation.Id, "user", searchQuery.Trim());
                        await ApiService.AddMessageToConversationAsync(currentConversation.Id, "assistant", searchResponse.RAGResponse);
                        
                        // Auto-generate title from first query if it's still "New Chat"
                        if (currentConversation.Title == "New Chat" && conversations != null)
                        {
                            var conversation = conversations.FirstOrDefault(c => c.Id == currentConversation.Id);
                            if (conversation != null)
                            {
                                // Generate a title from the first few words of the query
                                var title = searchQuery.Trim();
                                if (title.Length > 30)
                                {
                                    title = title.Substring(0, 30) + "...";
                                }
                                conversation.Title = title;
                                currentConversation.Title = title;
                                
                                // Refresh the conversation list to show the updated title
                                await LoadConversations();
                            }
                        }
                    }
                }
                else
                {
                    searchError = response.Error ?? "Unknown error occurred";
                }
            }
        }
        catch (Exception ex)
        {
            searchError = ex.Message;
        }
        finally
        {
            isSearching = false;
            searchQuery = string.Empty;
            StateHasChanged();
        }
    }

    private async Task ClearConversation()
    {
        await ConversationService.ClearConversationHistoryAsync();
        conversationHistory = new List<ConversationHistoryItem>();
        StateHasChanged(); // Force UI update
    }

    private async Task OnKeyPress(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !e.ShiftKey && !isSearching && !string.IsNullOrWhiteSpace(searchQuery))
        {
            await PerformSearch();
        }
    }

    private void OnInput(ChangeEventArgs e)
    {
        searchQuery = e.Value?.ToString() ?? "";
        StateHasChanged();
    }

    private string FormatResponse(string response)
    {
        if (string.IsNullOrEmpty(response))
            return response;

        // Configure Markdig pipeline for safe HTML rendering
        var pipeline = new MarkdownPipelineBuilder()
            .UseAdvancedExtensions()
            .UseBootstrap()
            .Build();

        // Convert markdown to HTML
        var html = Markdown.ToHtml(response, pipeline);
        
        return html;
    }

    private string GetSourceName(string source)
    {
        return Path.GetFileNameWithoutExtension(source);
    }

    private string TruncateContent(string content, int maxLength)
    {
        if (string.IsNullOrEmpty(content) || content.Length <= maxLength)
            return content;

        return content.Substring(0, maxLength) + "...";
    }

    private void ToggleResponseFormat()
    {
        isResponseExpanded = !isResponseExpanded;
    }

    private void ToggleSourceExpansion(SearchResult source)
    {
        if (expandedSources.Contains(source))
        {
            expandedSources.Remove(source);
        }
        else
        {
            expandedSources.Add(source);
        }
    }

    private bool IsSourceExpanded(SearchResult source)
    {
        return expandedSources.Contains(source);
    }

    private bool HasSources(string response)
    {
        // Simple check for sources - in a real implementation, you might want to parse the response
        return response.Contains("[") && response.Contains("]");
    }

    private void ToggleSourcesVisibility()
    {
        areSourcesVisible = !areSourcesVisible;
    }

    private void SetModel(string model)
    {
        selectedModel = model;
    }

    // Chat management methods
    private async Task LoadConversations()
    {
        conversationsLoading = true;
        StateHasChanged();

        try
        {
            var response = await ApiService.GetConversationsAsync();
            if (response.Success && response.Data != null)
            {
                conversations = response.Data;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading conversations: {ex.Message}");
        }
        finally
        {
            conversationsLoading = false;
            StateHasChanged();
        }
    }

    private async Task StartNewChat()
    {
        try
        {
            Console.WriteLine($"StartNewChat called. Current conversation: {currentConversation?.Id}, History count: {conversationHistory.Count}");
            
            // Add immediate feedback
            StateHasChanged();

            // Messages are already saved to the current conversation in the PerformSearch method.
            // All we need to do here is create a new conversation and refresh the list.
            Console.WriteLine(currentConversation != null && conversationHistory.Any()
                ? $"Finalizing conversation {currentConversation.Id} before starting a new one."
                : "No active conversation to save, starting a new one.");

            // Create a new conversation
            Console.WriteLine("Creating new conversation");
            var response = await ApiService.CreateConversationAsync();
            if (response.Success && response.Data != null)
            {
                Console.WriteLine($"New conversation created: {response.Data.Id}");
                currentConversation = response.Data;
                await ClearConversation(); // Clear local session storage
                await LoadConversations(); // Refresh conversation list
                StateHasChanged();
            }
            else
            {
                Console.WriteLine($"Failed to create new conversation: {response.Error}");
                // Even if API fails, clear local conversation
                await ClearConversation();
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error creating new conversation: {ex.Message}");
            Console.WriteLine($"Stack trace: {ex.StackTrace}");
            // Even if there's an error, clear local conversation
            await ClearConversation();
            StateHasChanged();
        }
    }

    private async Task LoadConversation(Guid conversationId)
    {
        try
        {
            var response = await ApiService.GetConversationAsync(conversationId);
            if (response.Success && response.Data != null)
            {
                currentConversation = response.Data;
                
                // Convert API messages to conversation history items
                var historyItems = new List<ConversationHistoryItem>();
                for (int i = 0; i < response.Data.Messages.Count; i += 2)
                {
                    // Group user and assistant messages together
                    var userMessage = response.Data.Messages[i];
                    var assistantMessage = i + 1 < response.Data.Messages.Count ? response.Data.Messages[i + 1] : null;
                    
                    if (userMessage.Role == "user")
                    {
                        historyItems.Add(new ConversationHistoryItem
                        {
                            Query = userMessage.Content,
                            Response = assistantMessage?.Role == "assistant" ? assistantMessage.Content : "",
                            Timestamp = userMessage.Timestamp
                        });
                    }
                }
                
                // Update local conversation history
                conversationHistory = historyItems;
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading conversation: {ex.Message}");
        }
    }

    private void ToggleSidebar()
    {
        isSidebarOpen = !isSidebarOpen;
    }

    private string GetConversationTitle(LocalAI.Core.Models.ChatConversationSummary conv)
    {
        if (!string.IsNullOrEmpty(conv.Title) && conv.Title != "New Chat")
            return conv.Title;
            
        // Generate title from first message if available
        // In a real implementation, this would come from the API or be stored locally
        // For now, we'll just return a truncated version of the title if it's not "New Chat"
        if (!string.IsNullOrEmpty(conv.Title))
        {
            var title = conv.Title;
            if (title.Length > 30)
            {
                title = title.Substring(0, 30) + "...";
            }
            return title;
        }
            
        return "New Chat";
    }

    // New conversation management methods
    private async Task StartEditTitle(Guid conversationId, string currentTitle)
    {
        editingConversationId = conversationId;
        editTitle = currentTitle;
        StateHasChanged();
        
        // Focus the input after render
        await InvokeAsync(async () =>
        {
            await Task.Delay(10);
            await titleEditInput.FocusAsync();
        });
    }

    private async Task SaveTitle(Guid conversationId)
    {
        if (!string.IsNullOrWhiteSpace(editTitle))
        {
            try
            {
                // Note: This would require a new API endpoint to update conversation titles
                // For now, we'll just update the local list
                var conversation = conversations.FirstOrDefault(c => c.Id == conversationId);
                if (conversation != null)
                {
                    conversation.Title = editTitle;
                }
                
                // If this is the current conversation, update it too
                if (currentConversation?.Id == conversationId)
                {
                    currentConversation.Title = editTitle;
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error saving title: {ex.Message}");
            }
        }
        
        editingConversationId = Guid.Empty;
        StateHasChanged();
    }

    private void CancelEditTitle()
    {
        editingConversationId = Guid.Empty;
        StateHasChanged();
    }

    private async Task HandleTitleEditKeydown(KeyboardEventArgs e, Guid conversationId)
    {
        if (e.Key == "Enter")
        {
            await SaveTitle(conversationId);
        }
        else if (e.Key == "Escape")
        {
            CancelEditTitle();
        }
    }

    private async Task DeleteConversation(Guid conversationId)
    {
        try
        {
            // Show confirmation dialog
            // Note: In a real implementation, you would use a proper modal dialog
            var confirm = true; // For now, we'll assume confirmation
            
            if (confirm)
            {
                var response = await ApiService.DeleteConversationAsync(conversationId);
                if (response.Success)
                {
                    // If we're deleting the current conversation, start a new one
                    if (currentConversation?.Id == conversationId)
                    {
                        await StartNewChat();
                    }
                    
                    // Refresh the conversations list
                    await LoadConversations();
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error deleting conversation: {ex.Message}");
        }
    }

    private async Task ShowPreview(Guid conversationId)
    {
        // Only show preview if we're not editing a title
        if (editingConversationId == Guid.Empty)
        {
            previewedConversationId = conversationId;
            
            // Generate a preview from the conversation
            // In a real implementation, this would come from the API
            var preview = "Preview of conversation...";
            conversationPreviews[conversationId] = preview;
            
            StateHasChanged();
        }
    }

    private void HidePreview()
    {
        previewedConversationId = Guid.Empty;
        StateHasChanged();
    }

    private void ToggleExamples()
    {
        showExamples = !showExamples;
        StateHasChanged();
    }
}
